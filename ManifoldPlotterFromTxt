import matplotlib.pyplot as plt
import numpy as np
from scipy.integrate import odeint
from mpl_toolkits.mplot3d import Axes3D
Axes3D
from sklearn import manifold, datasets
from Simulator import Simulator
from PoincareMapper import PoincareMapper
import Equation
import math
import numpy as np

manData = np.loadtxt('TSNEData.txt')
simData = np.loadtxt('Data.txt')

#Initiate
embedding= manifold.TSNE(n_components=1, init='pca', random_state=0)
# Plotting

i = 0
angles = np.linspace(0,2*np.pi,8)
for theta in angles:
    print("\n")
    print("Current angle = " + str(theta))
    spaceVec = np.array([np.cos(theta),np.sin(theta),0])
    planeVec = np.array([np.cos(theta),np.sin(theta)])

    dataMapper = PoincareMapper(spaceVec,simData.T,direction = 1)
    manifoldMapper = PoincareMapper(planeVec,manData,direction = 1)

    print("Computing return maps")
    returnMapData = dataMapper.getValues()
    #returnMapOfManifold = manifoldMapper.getValues() # manifold then return maps

    #for point in returnMapData:
    #    returnMapData2.append([np.sqrt(math.pow(point[0],2)+math.pow(point[1],2)),point[2]])

    returnMapOfManifold = embedding.fit_transform(returnMapData)


    #----------------------------------------------------------------------
    # Plot result

    fig = plt.figure(i)
    i = i + 1

    ax = fig.add_subplot(221, projection='3d')
    ax.plot(simData[0], simData[1], simData[2])
    ax.set_title("Original data")


    ax = fig.add_subplot(222)
    ax.scatter(returnMapOfManifold[:-1], returnMapOfManifold[1:])
    # plt.axis('tight')
    # plt.xticks([]), plt.yticks([])
    plt.title("Return map of transformed data")


    ax = fig.add_subplot(223)
    ax.plot(manData[:,0],manData[:,1])
    plt.title("Data after embedding")


    ax = fig.add_subplot(224)
    ax.scatter(returnMapData[:-1],returnMapData[1:])
    plt.title("Return map of embedded data")


plt.show()
